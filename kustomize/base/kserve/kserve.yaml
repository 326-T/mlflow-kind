---
# Source: kserve/templates/modelmesh/networkpolicy.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
  name: modelmesh-controller
spec:
  ingress:
    - ports:
        - port: 8443
          protocol: TCP
  podSelector:
    matchLabels:
      app.kubernetes.io/managed-by: modelmesh-controller
      control-plane: modelmesh-controller
  policyTypes:
    - Ingress
---
# Source: kserve/templates/modelmesh/networkpolicy.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
  name: modelmesh-runtimes
spec:
  ingress:
    - from:
        - podSelector:
            matchLabels:
              app.kubernetes.io/managed-by: modelmesh-controller
      ports:
        - port: 8033
          protocol: TCP
        - port: 8080
          protocol: TCP
    - ports:
        - port: 8033
          protocol: TCP
        - port: 8008
          protocol: TCP
    - ports:
        - port: 2112
          protocol: TCP
  podSelector:
    matchExpressions:
      - key: modelmesh-service
        operator: Exists
    matchLabels:
      app.kubernetes.io/managed-by: modelmesh-controller
  policyTypes:
    - Ingress
---
# Source: kserve/templates/modelmesh/networkpolicy.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
  name: modelmesh-webhook
spec:
  podSelector:
    matchLabels:
      app.kubernetes.io/managed-by: modelmesh-controller
      control-plane: modelmesh-controller
  ingress:
    # exposed for webhook
    - ports:
        - port: 9443
          protocol: TCP
  policyTypes:
    - Ingress
---
# Source: kserve/templates/modelmesh/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
  name: modelmesh
---
# Source: kserve/templates/modelmesh/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
  name: modelmesh-controller
---
# Source: kserve/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    app.kubernetes.io/instance: kserve-controller-manager
    app.kubernetes.io/managed-by: kserve-controller-manager
    app.kubernetes.io/name: kserve-controller-manager
  name: kserve-controller-manager
---
# Source: kserve/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: inferenceservice-config
  namespace: kserve
data:
  _example: |-
    ################################
    #                              #
    #    EXAMPLE CONFIGURATION     #
    #                              #
    ################################

    # This block is not actually functional configuration,
    # but serves to illustrate the available configuration
    # options and document them in a way that is accessible
    # to users that `kubectl edit` this config map.
    #
    # These sample configuration options may be copied out of
    # this example block and unindented to be in the data block
    # to actually change the configuration.

    # ====================================== EXPLAINERS CONFIGURATION ======================================
    # Example
    explainers: |-
      {
          "art": {
              "image" : "kserve/art-explainer",
              "defaultImageVersion": "latest"
          }
      }
    # Art Explainer runtime configuration
     explainers: |-
        {
            # Art explainer runtime configuration
            "art": {
                # image contains the default Art explainer serving runtime image uri.
                "image" : "kserve/art-explainer",

                # defautltImageVersion contains the Art explainer serving runtime default image version.
                "defaultImageVersion": "latest"
            }
        }

     # ====================================== STORAGE INITIALIZER CONFIGURATION ======================================
     # Example
     storageInitializer: |-
       {
           "image" : "kserve/storage-initializer:latest",
           "memoryRequest": "100Mi",
           "memoryLimit": "1Gi",
           "cpuRequest": "100m",
           "cpuLimit": "1",
           "enableDirectPvcVolumeMount": true,
           "enableModelcar": false,
           "cpuModelcar": "10m",
           "memoryModelcar": "15Mi"
       }
     storageInitializer: |-
       {
           # image contains the default storage initializer image uri.
           "image" : "kserve/storage-initializer:latest",

           # memoryRequest is the requests.memory to set for the storage initializer init container.
           "memoryRequest": "100Mi",

            # memoryLimit is the limits.memory to set for the storage initializer init container.
           "memoryLimit": "1Gi",

           # cpuRequest is the requests.cpu to set for the storage initializer init container.
           "cpuRequest": "100m",

           # cpuLimit is the limits.cpu to set for the storage initializer init container.
           "cpuLimit": "1",

           # enableDirectPvcVolumeMount controls whether users can mount pvc volumes directly.
           # if pvc volume is provided in storageuri then the pvc volume is directly mounted to /mnt/models in the user container.
           # rather than symlink it to a shared volume. For more info see https://github.com/kserve/kserve/issues/2737
           "enableDirectPvcVolumeMount": true,

           # enableModelcar enabled allows you to directly access an OCI container image by
           # using a source URL with an "oci://" schema.
           "enableModelcar": false,

           # cpuModelcar is the cpu request and limit that is used for the passive modelcar container. It can be
           # set very low, but should be allowed by any Kubernetes LimitRange that might apply.
           "cpuModelcar": "10m",

           # cpuModelcar is the memory request and limit that is used for the passive modelcar container. It can be
           # set very low, but should be allowed by any Kubernetes LimitRange that might apply.
           "memoryModelcar": "15Mi",

           # uidModelcar is the UID under with which the modelcar process and the main container is running.
           # Some Kubernetes clusters might require this to be root (0). If not set the user id is left untouched (default)
           "uidModelcar": 10
       }

     # ====================================== CREDENTIALS ======================================
     # Example
     credentials: |-
       {
          "storageSpecSecretName": "storage-config",
          "storageSecretNameAnnotation": "serving.kserve.io/storageSecretName",
          "gcs": {
              "gcsCredentialFileName": "gcloud-application-credentials.json"
          },
          "s3": {
              "s3AccessKeyIDName": "AWS_ACCESS_KEY_ID",
              "s3SecretAccessKeyName": "AWS_SECRET_ACCESS_KEY",
              "s3Endpoint": "",
              "s3UseHttps": "",
              "s3Region": "",
              "s3VerifySSL": "",
              "s3UseVirtualBucket": "",
              "s3UseAnonymousCredential": "",
              "s3CABundle": ""
          }
       }
     # This is a global configuration used for downloading models from the cloud storage.
     # You can override this configuration by specifying the annotations on service account or static secret.
     # https://kserve.github.io/website/master/modelserving/storage/s3/s3/
     # For a quick reference about AWS ENV variables:
     # AWS Cli: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html
     # Boto: https://boto3.amazonaws.com/v1/documentation/api/latest/guide/configuration.html#using-environment-variables
     #
     # The `s3AccessKeyIDName` and `s3SecretAccessKeyName` fields are only used from this configmap when static credentials (IAM User Access Key Secret)
     # are used as the authentication method for AWS S3.
     # The rest of the fields are used in both authentication methods (IAM Role for Service Account & IAM User Access Key Secret) if a non-empty value is provided.
     credentials: |-
       {
          # storageSpecSecretName contains the secret name which has the credentials for downloading the model.
          # This option is used when specifying the storage spec on isvc yaml.
          "storageSpecSecretName": "storage-config",

          # The annotation can be specified on isvc yaml to allow overriding with the secret name reference from the annotation value.
          # When using storageUri the order of the precedence is: secret name reference annotation > secret name references from service account
          # When using storageSpec the order of the precedence is: secret name reference annotation > storageSpecSecretName in configmap
          "storageSecretNameAnnotation": "serving.kserve.io/storageSecretName",
          # Configuration for google cloud storage
          "gcs": {
              # gcsCredentialFileName specifies the filename of the gcs credential
              "gcsCredentialFileName": "gcloud-application-credentials.json"
          },

          # Configuration for aws s3 storage. This add the corresponding environmental variables to the storage initializer init container.
          # For more info on s3 storage see https://kserve.github.io/website/master/modelserving/storage/s3/s3/
          "s3": {
              # s3AccessKeyIDName specifies the s3 access key id name
              "s3AccessKeyIDName": "AWS_ACCESS_KEY_ID",

              # s3SecretAccessKeyName specifies the s3 secret access key name
              "s3SecretAccessKeyName": "AWS_SECRET_ACCESS_KEY",

              # s3Endpoint specifies the s3 endpoint
              "s3Endpoint": "",

              # s3UseHttps controls whether to use secure https or unsecure http to download models.
              # Allowed values are 0 and 1.
              "s3UseHttps": "",

              # s3Region specifies the region of the bucket.
              "s3Region": "",

              # s3VerifySSL controls whether to verify the tls/ssl certificate.
              "s3VerifySSL": "",

              # s3UseVirtualBucket configures whether it is a virtual bucket or not.
              "s3UseVirtualBucket": "",

              # s3UseAnonymousCredential configures whether to use anonymous credentials to download the model or not.
              "s3UseAnonymousCredential": "",

              # s3CABundle specifies the path to a certificate bundle to use for HTTPS certificate validation.
              "s3CABundle": ""
          }
       }

     # ====================================== INGRESS CONFIGURATION ======================================
     # Example
     ingress: |-
       {
           "ingressGateway" : "knative-serving/knative-ingress-gateway",
           "localGateway" : "knative-serving/knative-local-gateway",
           "localGatewayService" : "knative-local-gateway.istio-system.svc.cluster.local",
           "ingressDomain"  : "example.com",
           "additionalIngressDomains": ["additional-example.com", "additional-example-1.com"],
           "ingressClassName" : "istio",
           "domainTemplate": "-.",
           "urlScheme": "http",
           "disableIstioVirtualHost": false,
           "disableIngressCreation": false
       }
     ingress: |-
       {
           # ingressGateway specifies the ingress gateway to serve external traffic.
           # The gateway should be specified in format <gateway namespace>/<gateway name>
           # NOTE: This configuration only applicable for serverless deployment with Istio configured as network layer.
           "ingressGateway" : "knative-serving/knative-ingress-gateway",

           # knativeLocalGatewayService specifies the hostname of the Knative's local gateway service.
           # The default KServe configurations are re-using the Istio local gateways for Knative. In this case, this
           # knativeLocalGatewayService field can be left unset. When unset, the value of "localGatewayService" will be used.
           # However, sometimes it may be better to have local gateways specifically for KServe (e.g. when enabling strict mTLS in Istio).
           # Under such setups where KServe is needed to have its own local gateways, the values of the "localGateway" and
           # "localGatewayService" should point to the KServe local gateways. Then, this knativeLocalGatewayService field
           # should point to the Knative's local gateway service.
           # NOTE: This configuration only applicable for serverless deployment with Istio configured as network layer.
           "knativeLocalGatewayService": "",

           # localGateway specifies the gateway which handles the network traffic within the cluster.
           # NOTE: This configuration only applicable for serverless deployment with Istio configured as network layer.
           "localGateway" : "knative-serving/knative-local-gateway",

           # localGatewayService specifies the hostname of the local gateway service.
           # NOTE: This configuration only applicable for serverless deployment with Istio configured as network layer.
           "localGatewayService" : "knative-local-gateway.istio-system.svc.cluster.local",

           # ingressDomain specifies the domain name which is used for creating the url.
           # If ingressDomain is empty then example.com is used as default domain.
           # NOTE: This configuration only applicable for raw deployment.
           "ingressDomain"  : "example.com",

           # additionalIngressDomains specifies the additional domain names which are used for creating the url.
           "additionalIngressDomains": ["additional-example.com", "additional-example-1.com"]

           # ingressClassName specifies the ingress controller to use for ingress traffic.
           # This is optional and if omitted the default ingress in the cluster is used.
           # https://kubernetes.io/docs/concepts/services-networking/ingress/#default-ingress-class
           # NOTE: This configuration only applicable for raw deployment.
           "ingressClassName" : "istio",

           # domainTemplate specifies the template for generating domain/url for each inference service by combining variable from:
           # Name of the inference service  ({{ .Name }})
           # Namespace of the inference service ({{ .Namespace }})
           # Annotation of the inference service ({{ .Annotations.key }})
           # Label of the inference service ({{ .Labels.key }})
           # IngressDomain ({{ .IngressDomain }})
           # If domain template is empty the default template ({{ .Name }}-{{ .Namespace }}.{{ .IngressDomain }}) is used.
           # NOTE: This configuration only applicable for raw deployment.
           "domainTemplate": "-.",

           # urlScheme specifies the url scheme to use for inference service and inference graph.
           # If urlScheme is empty then by default http is used.
           "urlScheme": "http",

           # disableIstioVirtualHost controls whether to use istio as network layer.
           # By default istio is used as the network layer. When DisableIstioVirtualHost is true, KServe does not
           # create the top level virtual service thus Istio is no longer required for serverless mode.
           # By setting this field to true, user can use other networking layers supported by knative.
           # For more info https://github.com/kserve/kserve/pull/2380, https://kserve.github.io/website/master/admin/serverless/kourier_networking/.
           # NOTE: This configuration is only applicable to serverless deployment.
           "disableIstioVirtualHost": false,

           # disableIngressCreation controls whether to disable ingress creation for raw deployment mode.
           "disableIngressCreation": false,

           # pathTemplate specifies the template for generating path based url for each inference service.
           # The following variables can be used in the template for generating url.
           # Name of the inference service ({{ .Name }})
           # Namespace of the inference service ({{ .Namespace }})
           # For more info https://github.com/kserve/kserve/issues/2257.
           # NOTE: This configuration only applicable to serverless deployment.
           "pathTemplate": "/serving//"
       }

     # ====================================== LOGGER CONFIGURATION ======================================
     # Example
     logger: |-
       {
           "image" : "kserve/agent:latest",
           "memoryRequest": "100Mi",
           "memoryLimit": "1Gi",
           "cpuRequest": "100m",
           "cpuLimit": "1",
           "defaultUrl": "http://default-broker"
       }
     logger: |-
       {
           # image contains the default logger image uri.
           "image" : "kserve/agent:latest",

           # memoryRequest is the requests.memory to set for the logger container.
           "memoryRequest": "100Mi",

           # memoryLimit is the limits.memory to set for the logger container.
           "memoryLimit": "1Gi",

           # cpuRequest is the requests.cpu to set for the logger container.
           "cpuRequest": "100m",

           # cpuLimit is the limits.cpu to set for the logger container.
           "cpuLimit": "1",

           # defaultUrl specifies the default logger url. If logger is not specified in the resource this url is used.
           "defaultUrl": "http://default-broker"
       }

     # ====================================== BATCHER CONFIGURATION ======================================
     # Example
     batcher: |-
       {
           "image" : "kserve/agent:latest",
           "memoryRequest": "1Gi",
           "memoryLimit": "1Gi",
           "cpuRequest": "1",
           "cpuLimit": "1",
           "maxBatchSize": "32",
           "maxLatency": "5000"
       }
     batcher: |-
       {
           # image contains the default batcher image uri.
           "image" : "kserve/agent:latest",

           # memoryRequest is the requests.memory to set for the batcher container.
           "memoryRequest": "1Gi",

           # memoryLimit is the limits.memory to set for the batcher container.
           "memoryLimit": "1Gi",

           # cpuRequest is the requests.cpu to set for the batcher container.
           "cpuRequest": "1",

           # cpuLimit is the limits.cpu to set for the batcher container.
           "cpuLimit": "1"

           # maxBatchSize is the default maximum batch size for batcher.
           "maxBatchSize": "32",

           # maxLatency is the default maximum latency in milliseconds for batcher to wait and collect the batch.
           "maxLatency": "5000"
       }

     # ====================================== AGENT CONFIGURATION ======================================
     # Example
     agent: |-
       {
           "image" : "kserve/agent:latest",
           "memoryRequest": "100Mi",
           "memoryLimit": "1Gi",
           "cpuRequest": "100m",
           "cpuLimit": "1"
       }
     agent: |-
       {
           # image contains the default agent image uri.
           "image" : "kserve/agent:latest",

           # memoryRequest is the requests.memory to set for the agent container.
           "memoryRequest": "100Mi",

           # memoryLimit is the limits.memory to set for the agent container.
           "memoryLimit": "1Gi",

           # cpuRequest is the requests.cpu to set for the agent container.
           "cpuRequest": "100m",

           # cpuLimit is the limits.cpu to set for the agent container.
           "cpuLimit": "1"
       }

     # ====================================== ROUTER CONFIGURATION ======================================
     # Example
     router: |-
       {
           "image" : "kserve/router:latest",
           "memoryRequest": "100Mi",
           "memoryLimit": "1Gi",
           "cpuRequest": "100m",
           "cpuLimit": "1",
           "headers": {
             "propagate": []
           }
       }
     # router is the implementation of inference graph.
     router: |-
       {
           # image contains the default router image uri.
           "image" : "kserve/router:latest",

           # memoryRequest is the requests.memory to set for the router container.
           "memoryRequest": "100Mi",

           # memoryLimit is the limits.memory to set for the router container.
           "memoryLimit": "1Gi",

           # cpuRequest is the requests.cpu to set for the router container.
           "cpuRequest": "100m",

           # cpuLimit is the limits.cpu to set for the router container.
           "cpuLimit": "1"

           # Propagate the specified headers to all the steps specified in an InferenceGraph.
           # You can either specify the exact header names or use [Golang supported regex patterns]
           # (https://pkg.go.dev/regexp/syntax@go1.21.3#hdr-Syntax) to propagate multiple headers.
           "headers": {
             "propagate": [
                "Authorization",
                "Test-Header-*",
                "*Trace-Id*"
             ]
           }
       }

     # ====================================== DEPLOYMENT CONFIGURATION ======================================
     # Example
     deploy: |-
       {
         "defaultDeploymentMode": "Serverless"
       }
     deploy: |-
       {
         # defaultDeploymentMode specifies the default deployment mode of the kserve. The supported values are
         # Serverless, RawDeployment and ModelMesh. Users can override the deployment mode at service level
         # by adding the annotation serving.kserve.io/deploymentMode.For more info on deployment mode visit
         # Serverless https://kserve.github.io/website/master/admin/serverless/serverless/
         # RawDeployment https://kserve.github.io/website/master/admin/kubernetes_deployment/
         # ModelMesh https://kserve.github.io/website/master/admin/modelmesh/
         "defaultDeploymentMode": "Serverless"
       }

     # ====================================== METRICS CONFIGURATION ======================================
     # Example
     metricsAggregator: |-
       {
         "enableMetricAggregation": "false",
         "enablePrometheusScraping" : "false"
       }
     # For more info see https://github.com/kserve/kserve/blob/master/qpext/README.md
     metricsAggregator: |-
       {
         # enableMetricAggregation configures metric aggregation annotation. This adds the annotation serving.kserve.io/enable-metric-aggregation to every
         # service with the specified boolean value. If true enables metric aggregation in queue-proxy by setting env vars in the queue proxy container
         # to configure scraping ports.
         "enableMetricAggregation": "false",

         # enablePrometheusScraping configures metric aggregation annotation. This adds the annotation serving.kserve.io/enable-metric-aggregation to every
         # service with the specified boolean value. If true, prometheus annotations are added to the pod. If serving.kserve.io/enable-metric-aggregation is false,
         # the prometheus port is set with the default prometheus scraping port 9090, otherwise the prometheus port annotation is set with the metric aggregation port.
         "enablePrometheusScraping" : "false"
       }

     # ====================================== LOCALMODEL CONFIGURATION ======================================
     # Example
     localModel: |-
       {
         "enabled": false,
         # jobNamespace specifies the namespace where the download job will be created.
         "jobNamespace": "kserve-localmodel-jobs",
         # defaultJobImage specifies the default image used for the download job.
         "defaultJobImage" : "kserve/storage-initializer:latest",
         # Kubernetes modifies the filesystem group ID on the attached volume.
         "FSGroup": 1000
       }

  agent: |-
    {
        "image" : "kserve/agent:v0.14.0",
        "memoryRequest": "100Mi",
        "memoryLimit": "1Gi",
        "cpuRequest": "100m",
        "cpuLimit": "1"
    }
  batcher: |-
    {
        "image" : "kserve/agent:v0.14.0",
        "memoryRequest": "1Gi",
        "memoryLimit": "1Gi",
        "cpuRequest": "1",
        "cpuLimit": "1",
        "maxBatchSize": "32",
        "maxLatency": "5000"
    }
  router: |-
    {
        "image" : "kserve/router:v0.14.0",
        "memoryRequest": "100Mi",
        "memoryLimit": "1Gi",
        "cpuRequest": "100m",
        "cpuLimit": "1"
    }
  credentials: |-
    {
       "storageSpecSecretName": "storage-config",
       "storageSecretNameAnnotation": "serving.kserve.io/secretName",
       "gcs": {
           "gcsCredentialFileName": "gcloud-application-credentials.json"
       },
       "s3": {
           "s3AccessKeyIDName": "AWS_ACCESS_KEY_ID",
           "s3SecretAccessKeyName": "AWS_SECRET_ACCESS_KEY",
           "s3Endpoint": "",
           "s3UseHttps": "",
           "s3Region": "",
           "s3VerifySSL": "",
           "s3UseVirtualBucket": "",
           "s3UseAnonymousCredential": "",
           "s3CABundle": ""
       }
    }
  deploy: |-
    {
      "defaultDeploymentMode": "Serverless"
    }
  explainers: |-
    {
        "art": {
            "image" : "kserve/art-explainer",
            "defaultImageVersion": "v0.14.0"
        }
    }
  ingress: |-
    {
        "ingressGateway" : "knative-serving/knative-ingress-gateway",
        "knativeLocalGatewayService" : "",
        "localGateway" : "knative-serving/knative-local-gateway",
        "localGatewayService" : "knative-local-gateway.istio-system.svc.cluster.local",
        "ingressClassName" : "istio",
        "ingressDomain"  : "example.com",
        "additionalIngressDomains": [
        ],
        "domainTemplate": "{{ .Name }}-{{ .Namespace }}.{{ .IngressDomain }}",
        "urlScheme": "http",
        "disableIstioVirtualHost": false,
        "disableIngressCreation": false
    }
  logger: |-
    {
        "image" : "kserve/agent:v0.14.0",
        "memoryRequest": "100Mi",
        "memoryLimit": "1Gi",
        "cpuRequest": "100m",
        "cpuLimit": "1",
        "defaultUrl": "http://default-broker"
    }
  storageInitializer: |-
    {
        "image" : "kserve/storage-initializer:v0.14.0",
        "memoryRequest": "100Mi",
        "memoryLimit": "1Gi",
        "cpuRequest": "100m",
        "cpuLimit": "1",
        "enableDirectPvcVolumeMount": true,
        "caBundleConfigMapName": "",
        "caBundleVolumeMountPath": "/etc/ssl/custom-certs",
        "enableModelcar": false,
        "cpuModelcar": "10m",
        "memoryModelcar": "15Mi"
    }
  metricsAggregator: |-
    {
      "enableMetricAggregation": "false",
      "enablePrometheusScraping" : "false"
    }
  localModel: |-
    {
      "enabled": false,
      "jobNamespace": "kserve-localmodel-jobs",
      "defaultJobImage" : "kserve/storage-initializer:latest",
      "FSGroup": 1000
    }
  security: |-
    {
      "autoMountServiceAccountToken": true
    }
---
# Source: kserve/templates/modelmesh/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
  name: model-serving-config-defaults
data:
  config-defaults.yaml: |
    podsPerRuntime: 
    headlessService: true
    modelMeshImage:
      name: kserve/modelmesh
      tag: v0.12.0
    modelMeshResources:
      requests:
        cpu: "300m"
        memory: "448Mi"
      limits:
        cpu: "3"
        memory: "448Mi"
    restProxy:
      enabled: true
      port: 8008
      image:
        name: kserve/rest-proxy
        tag: v0.12.0
      resources:
        requests:
          cpu: "50m"
          memory: "96Mi"
        limits:
          cpu: "1"
          memory: "512Mi"
    storageHelperImage:
      name: kserve/modelmesh-runtime-adapter
      tag: v0.12.0
      command: ["/opt/app/puller"]
    storageHelperResources:
      requests:
        cpu: "50m"
        memory: "96Mi"
      limits:
        cpu: "2"
        memory: "512Mi"
    serviceAccountName: ""
    metrics:
      enabled: true
    builtInServerTypes:
      - triton
      - mlserver
      - ovms
      - torchserve
---
# Source: kserve/templates/clusterrole.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: kserve-proxy-role
rules:
  - apiGroups: ["authentication.k8s.io"]
    resources:
      - tokenreviews
    verbs: ["create"]
  - apiGroups: ["authorization.k8s.io"]
    resources:
      - subjectaccessreviews
    verbs: ["create"]
---
# Source: kserve/templates/clusterrole.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: kserve-manager-role
rules:
  - apiGroups:
      - ""
    resources:
      - configmaps
    verbs:
      - create
      - get
      - update
  - apiGroups:
      - ""
    resources:
      - events
      - services
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - ""
    resources:
      - namespaces
      - pods
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - ""
    resources:
      - secrets
      - serviceaccounts
    verbs:
      - get
  - apiGroups:
      - admissionregistration.k8s.io
    resources:
      - mutatingwebhookconfigurations
      - validatingwebhookconfigurations
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - apps
    resources:
      - deployments
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - autoscaling
    resources:
      - horizontalpodautoscalers
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - networking.istio.io
    resources:
      - virtualservices
      - virtualservices/finalizers
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - networking.istio.io
    resources:
      - virtualservices/status
    verbs:
      - get
      - patch
      - update
  - apiGroups:
      - networking.k8s.io
    resources:
      - ingresses
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - serving.knative.dev
    resources:
      - services
      - services/finalizers
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - serving.knative.dev
    resources:
      - services/status
    verbs:
      - get
      - patch
      - update
  - apiGroups:
      - serving.kserve.io
    resources:
      - clusterlocalmodels
    verbs:
      - get
      - list
  - apiGroups:
      - serving.kserve.io
    resources:
      - clusterservingruntimes
      - clusterservingruntimes/finalizers
      - clusterstoragecontainers
      - inferencegraphs
      - inferencegraphs/finalizers
      - inferenceservices
      - inferenceservices/finalizers
      - servingruntimes
      - servingruntimes/finalizers
      - trainedmodels
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - serving.kserve.io
    resources:
      - clusterservingruntimes/status
      - inferencegraphs/status
      - inferenceservices/status
      - servingruntimes/status
      - trainedmodels/status
    verbs:
      - get
      - patch
      - update
---
# Source: kserve/templates/modelmesh/clusterrole.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: modelmesh-controller-role
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
rules:
  - apiGroups:
      - ""
    resources:
      - configmaps
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - ""
    resources:
      - endpoints
      - persistentvolumeclaims
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - ""
    resources:
      - namespaces
      - namespaces/finalizers
    verbs:
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - ""
    resources:
      - secrets
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - ""
    resources:
      - services
      - services/finalizers
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - apps
    resources:
      - deployments
      - deployments/finalizers
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - monitoring.coreos.com
    resources:
      - servicemonitors
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - serving.kserve.io
    resources:
      - inferenceservices
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - serving.kserve.io
    resources:
      - inferenceservices/finalizers
    verbs:
      - get
      - patch
      - update
  - apiGroups:
      - serving.kserve.io
    resources:
      - inferenceservices/status
    verbs:
      - get
      - patch
      - update
  - apiGroups:
      - serving.kserve.io
    resources:
      - predictors
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - serving.kserve.io
    resources:
      - predictors/finalizers
    verbs:
      - get
      - patch
      - update
  - apiGroups:
      - serving.kserve.io
    resources:
      - predictors/status
    verbs:
      - get
      - patch
      - update
  - apiGroups:
      - serving.kserve.io
    resources:
      - servingruntimes
      - servingruntimes/finalizers
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - serving.kserve.io
    resources:
      - servingruntimes/status
    verbs:
      - get
      - patch
      - update
  - apiGroups:
      - serving.kserve.io
    resources:
      - clusterservingruntimes
      - clusterservingruntimes/finalizers
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - serving.kserve.io
    resources:
      - clusterservingruntimes/status
    verbs:
      - get
      - patch
      - update
  - apiGroups:
      - autoscaling
    resources:
      - horizontalpodautoscalers
      - horizontalpodautoscalers/status
    verbs:
      - get
      - list
      - watch
      - create
      - delete
      - update
---
# Source: kserve/templates/clusterrolebinding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: kserve-proxy-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: kserve-proxy-role
subjects:
  - kind: ServiceAccount
    name: kserve-controller-manager
    namespace: kserve
---
# Source: kserve/templates/clusterrolebinding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: kserve-manager-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: kserve-manager-role
subjects:
  - kind: ServiceAccount
    name: kserve-controller-manager
    namespace: kserve
---
# Source: kserve/templates/modelmesh/clusterrolebinding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
  name: modelmesh-controller-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: modelmesh-controller-role
subjects:
  - kind: ServiceAccount
    name: modelmesh-controller
    namespace: kserve
---
# Source: kserve/templates/modelmesh/role.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
  name: modelmesh-controller-leader-election-role
rules:
  - apiGroups:
      - coordination.k8s.io
    resources:
      - leases
    verbs:
      - create
      - get
      - list
      - update
  - apiGroups:
      - ""
    resources:
      - configmaps
    verbs:
      - get
      - list
      - watch
      - create
      - update
      - patch
      - delete
  - apiGroups:
      - ""
    resources:
      - events
    verbs:
      - create
---
# Source: kserve/templates/modelmesh/role.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
  name: modelmesh-controller-restricted-scc
rules:
  - apiGroups:
      - security.openshift.io
    resourceNames:
      - restricted
    resources:
      - securitycontextconstraints
    verbs:
      - use
---
# Source: kserve/templates/role.yaml
# permissions to do leader election.
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: kserve-leader-election-role
rules:
  - apiGroups:
      - coordination.k8s.io
    resources:
      - leases
    verbs:
      - create
      - get
      - list
      - update
  - apiGroups:
      - ""
    resources:
      - configmaps
    verbs:
      - get
      - list
      - watch
      - create
      - update
      - patch
      - delete
  - apiGroups:
      - ""
    resources:
      - configmaps/status
    verbs:
      - get
      - update
      - patch
  - apiGroups:
      - ""
    resources:
      - events
    verbs:
      - create
---
# Source: kserve/templates/modelmesh/rolebinding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
  name: modelmesh-controller-leader-election-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: modelmesh-controller-leader-election-role
subjects:
  - kind: ServiceAccount
    name: modelmesh-controller
---
# Source: kserve/templates/modelmesh/rolebinding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
  name: modelmesh-controller-restricted-scc
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: modelmesh-controller-restricted-scc
subjects:
  - kind: ServiceAccount
    name: modelmesh-controller
---
# Source: kserve/templates/rolebinding.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: kserve-leader-election-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: kserve-leader-election-role
subjects:
  - kind: ServiceAccount
    name: kserve-controller-manager
    namespace: kserve
---
# Source: kserve/templates/modelmesh/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: modelmesh-webhook-server-service
  namespace: kserve
spec:
  ports:
    - port: 9443
      protocol: TCP
      targetPort: webhook
  selector:
    control-plane: modelmesh-controller
---
# Source: kserve/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: kserve-webhook-server-service
  namespace: kserve
spec:
  ports:
    - port: 443
      targetPort: webhook-server
  selector:
    control-plane: kserve-controller-manager
---
# Source: kserve/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: kserve-controller-manager-service
  namespace: kserve
  labels:
    control-plane: kserve-controller-manager
    controller-tools.k8s.io: "1.0"
spec:
  selector:
    control-plane: kserve-controller-manager
    controller-tools.k8s.io: "1.0"
  ports:
    - port: 8443
      targetPort: https
      protocol: TCP
---
# Source: kserve/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kserve-controller-manager
  namespace: kserve
  labels:
    app.kubernetes.io/name: kserve-controller-manager
    control-plane: kserve-controller-manager
    controller-tools.k8s.io: "1.0"
  annotations:
    prometheus.io/scrape: "true"
spec:
  selector:
    matchLabels:
      control-plane: kserve-controller-manager
      controller-tools.k8s.io: "1.0"
  template:
    metadata:
      labels:
        app.kubernetes.io/name: kserve-controller-manager
        control-plane: kserve-controller-manager
        controller-tools.k8s.io: "1.0"
      annotations:
        kubectl.kubernetes.io/default-container: manager
    spec:
      serviceAccountName: kserve-controller-manager
      securityContext:
        runAsNonRoot: true
      containers:
        - name: kube-rbac-proxy
          image: "quay.io/brancz/kube-rbac-proxy:v0.18.0"
          args:
            - "--secure-listen-address=0.0.0.0:8443"
            - "--upstream=http://127.0.0.1:8080/"
            - "--logtostderr=true"
            - "--v=10"
          ports:
            - containerPort: 8443
              name: https
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
                - ALL
            privileged: false
            readOnlyRootFilesystem: true
            runAsNonRoot: true
          resources:
            limits:
              cpu: 100m
              memory: 300Mi
            requests:
              cpu: 100m
              memory: 300Mi
        - command:
            - /manager
          image: "kserve/kserve-controller:v0.14.0"
          imagePullPolicy: IfNotPresent
          name: manager
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
                - ALL
            privileged: false
            readOnlyRootFilesystem: true
            runAsNonRoot: true
          args:
            - "--metrics-addr=127.0.0.1:8080"
            - "--leader-elect"
          env:
            - name: POD_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
            - name: SECRET_NAME
              value: kserve-webhook-server-cert
          livenessProbe:
            failureThreshold: 5
            initialDelaySeconds: 10
            httpGet:
              path: /healthz
              port: 8081
            timeoutSeconds: 5
          readinessProbe:
            initialDelaySeconds: 10
            failureThreshold: 10
            periodSeconds: 5
            httpGet:
              path: /readyz
              port: 8081
            timeoutSeconds: 5
          resources:
            limits:
              cpu: 100m
              memory: 300Mi
            requests:
              cpu: 100m
              memory: 300Mi
          ports:
            - containerPort: 9443
              name: webhook-server
              protocol: TCP
            - containerPort: 8080
              name: metrics
              protocol: TCP
          volumeMounts:
            - mountPath: /tmp/k8s-webhook-server/serving-certs
              name: cert
              readOnly: true
      terminationGracePeriodSeconds: 10
      volumes:
        - name: cert
          secret:
            defaultMode: 420
            secretName: kserve-webhook-server-cert
---
# Source: kserve/templates/modelmesh/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
    control-plane: modelmesh-controller
  name: modelmesh-controller
  namespace: kserve
spec:
  replicas: 1
  selector:
    matchLabels:
      control-plane: modelmesh-controller
  template:
    metadata:
      labels:
        app.kubernetes.io/instance: modelmesh-controller
        app.kubernetes.io/managed-by: modelmesh-controller
        app.kubernetes.io/name: modelmesh-controller
        control-plane: modelmesh-controller
    spec:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchExpressions:
                    - key: control-plane
                      operator: In
                      values:
                        - modelmesh-controller
                topologyKey: topology.kubernetes.io/zone
              weight: 100
      containers:
        - args:
            - --enable-leader-election
          command:
            - /manager
          env:
            - name: NAMESPACE_SCOPE
              value: "false"
            - name: POD_NAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: ETCD_SECRET_NAME
              value: model-serving-etcd
          image: kserve/modelmesh-controller:v0.12.0
          livenessProbe:
            httpGet:
              path: /healthz
              port: 8081
            initialDelaySeconds: 15
            periodSeconds: 10
          name: manager
          ports:
            - containerPort: 9443
              name: webhook
              protocol: TCP
          readinessProbe:
            httpGet:
              path: /readyz
              port: 8081
            initialDelaySeconds: 10
            periodSeconds: 5
          resources:
            limits:
              cpu: "1"
              memory: 512Mi
            requests:
              cpu: 50m
              memory: 96Mi
          securityContext:
            capabilities:
              drop:
                - ALL
          volumeMounts:
            - mountPath: /etc/model-serving/config/default
              name: config-defaults
              readOnly: true
            - mountPath: /tmp/k8s-webhook-server/serving-certs
              name: modelmesh-webhook-server-cert
              readOnly: true
      serviceAccountName: modelmesh-controller
      terminationGracePeriodSeconds: 10
      volumes:
        - name: config-defaults
          configMap:
            defaultMode: 420
            name: model-serving-config-defaults
        - name: modelmesh-webhook-server-cert
          secret:
            defaultMode: 420
            secretName: modelmesh-webhook-server-cert
---
# Source: kserve/templates/certificate.yaml
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: serving-cert
  namespace: kserve
spec:
  commonName: kserve-webhook-server-service.kserve.svc
  dnsNames:
    - kserve-webhook-server-service.kserve.svc
  issuerRef:
    kind: Issuer
    name: selfsigned-issuer
  secretName: kserve-webhook-server-cert
---
# Source: kserve/templates/modelmesh/certificate.yaml
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: modelmesh-webhook-server-cert
  namespace: kserve
spec:
  commonName: modelmesh-webhook-server-service.kserve.svc
  dnsNames:
    - modelmesh-webhook-server-service.kserve.svc
    - modelmesh-webhook-server-service.kserve.svc.cluster.local
  issuerRef:
    kind: Issuer
    name: selfsigned-issuer
  secretName: modelmesh-webhook-server-cert
---
# Source: kserve/templates/clusterservingruntimes.yaml
apiVersion: serving.kserve.io/v1alpha1
kind: ClusterServingRuntime
metadata:
  name: kserve-lgbserver
spec:
  annotations:
    prometheus.kserve.io/port: "8080"
    prometheus.kserve.io/path: "/metrics"
  supportedModelFormats:
    - name: lightgbm
      version: "3"
      autoSelect: true
      priority: 1
  protocolVersions:
    - v1
    - v2
  containers:
    - name: kserve-container
      image: "kserve/lgbserver:v0.14.0"
      args:
        - --model_name={{.Name}}
        - --model_dir=/mnt/models
        - --http_port=8080
        - --nthread=1
      securityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
            - ALL
        privileged: false
        runAsNonRoot: true
      resources:
        requests:
          cpu: "1"
          memory: 2Gi
        limits:
          cpu: "1"
          memory: 2Gi
---
# Source: kserve/templates/clusterservingruntimes.yaml
apiVersion: serving.kserve.io/v1alpha1
kind: ClusterServingRuntime
metadata:
  name: kserve-mlserver
spec:
  annotations:
    # mlserver version 1.1.0 uses port 8082 as default instead of 8080.
    prometheus.kserve.io/port: "8080"
    prometheus.kserve.io/path: "/metrics"
  supportedModelFormats:
    - name: sklearn
      version: "0"
      autoSelect: true
      priority: 2
    - name: sklearn
      version: "1"
      autoSelect: true
      priority: 2
    - name: xgboost
      version: "1"
      autoSelect: true
      priority: 2
    - name: xgboost
      version: "2"
      autoSelect: true
      priority: 2
    - name: lightgbm
      version: "3"
      autoSelect: true
      priority: 2
    - name: lightgbm
      version: "4"
      autoSelect: true
      priority: 2
    - name: mlflow
      version: "1"
      autoSelect: true
      priority: 1
    - name: mlflow
      version: "2"
      autoSelect: true
      priority: 1
  protocolVersions:
    - v2
  containers:
    - name: kserve-container
      image: "docker.io/seldonio/mlserver:1.5.0"
      env:
        - name: "MLSERVER_MODEL_IMPLEMENTATION"
          value: "{{.Labels.modelClass}}"
        - name: "MLSERVER_HTTP_PORT"
          value: "8080"
        - name: "MLSERVER_GRPC_PORT"
          value: "9000"
        - name: "MODELS_DIR"
          value: "/mnt/models"
      securityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
            - ALL
        privileged: false
        runAsNonRoot: true
      resources:
        requests:
          cpu: "1"
          memory: 2Gi
        limits:
          cpu: "1"
          memory: 2Gi
---
# Source: kserve/templates/clusterservingruntimes.yaml
apiVersion: serving.kserve.io/v1alpha1
kind: ClusterServingRuntime
metadata:
  name: kserve-paddleserver
spec:
  annotations:
    prometheus.kserve.io/port: "8080"
    prometheus.kserve.io/path: "/metrics"
  supportedModelFormats:
    - name: paddle
      version: "2"
      autoSelect: true
      priority: 1
  protocolVersions:
    - v1
    - v2
  containers:
    - name: kserve-container
      image: "kserve/paddleserver:v0.14.0"
      args:
        - --model_name={{.Name}}
        - --model_dir=/mnt/models
        - --http_port=8080
      securityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
            - ALL
        privileged: false
        runAsNonRoot: true
      resources:
        requests:
          cpu: "1"
          memory: 2Gi
        limits:
          cpu: "1"
          memory: 2Gi
---
# Source: kserve/templates/clusterservingruntimes.yaml
apiVersion: serving.kserve.io/v1alpha1
kind: ClusterServingRuntime
metadata:
  name: kserve-pmmlserver
spec:
  annotations:
    prometheus.kserve.io/port: "8080"
    prometheus.kserve.io/path: "/metrics"
  supportedModelFormats:
    - name: pmml
      version: "3"
      autoSelect: true
      priority: 1
    - name: pmml
      version: "4"
      autoSelect: true
      priority: 1
  protocolVersions:
    - v1
    - v2
  containers:
    - name: kserve-container
      image: "kserve/pmmlserver:v0.14.0"
      args:
        - --model_name={{.Name}}
        - --model_dir=/mnt/models
        - --http_port=8080
      securityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
            - ALL
        privileged: false
        runAsNonRoot: true
      resources:
        requests:
          cpu: "1"
          memory: 2Gi
        limits:
          cpu: "1"
          memory: 2Gi
---
# Source: kserve/templates/clusterservingruntimes.yaml
apiVersion: serving.kserve.io/v1alpha1
kind: ClusterServingRuntime
metadata:
  name: kserve-sklearnserver
spec:
  annotations:
    prometheus.kserve.io/port: "8080"
    prometheus.kserve.io/path: "/metrics"
  supportedModelFormats:
    - name: sklearn
      version: "1"
      autoSelect: true
      priority: 1
  protocolVersions:
    - v1
    - v2
  containers:
    - name: kserve-container
      image: "kserve/sklearnserver:v0.14.0"
      args:
        - --model_name={{.Name}}
        - --model_dir=/mnt/models
        - --http_port=8080
      securityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
            - ALL
        privileged: false
        runAsNonRoot: true
      resources:
        requests:
          cpu: "1"
          memory: 2Gi
        limits:
          cpu: "1"
          memory: 2Gi
---
# Source: kserve/templates/clusterservingruntimes.yaml
apiVersion: serving.kserve.io/v1alpha1
kind: ClusterServingRuntime
metadata:
  name: kserve-tensorflow-serving
spec:
  annotations:
    prometheus.kserve.io/port: "8080"
    prometheus.kserve.io/path: "/metrics"
  supportedModelFormats:
    - name: tensorflow
      version: "1"
      autoSelect: true
      priority: 2
    - name: tensorflow
      version: "2"
      autoSelect: true
      priority: 2
  protocolVersions:
    - v1
    - grpc-v1
  containers:
    - name: kserve-container
      image: "tensorflow/serving:2.6.2"
      command: [/usr/bin/tensorflow_model_server]
      args:
        - --model_name={{.Name}}
        - --port=9000
        - --rest_api_port=8080
        - --model_base_path=/mnt/models
        - --rest_api_timeout_in_ms=60000
      securityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
            - ALL
        privileged: false
        runAsNonRoot: true
        runAsUser: 1000
      resources:
        requests:
          cpu: "1"
          memory: 2Gi
        limits:
          cpu: "1"
          memory: 2Gi
---
# Source: kserve/templates/clusterservingruntimes.yaml
apiVersion: serving.kserve.io/v1alpha1
kind: ClusterServingRuntime
metadata:
  name: kserve-torchserve
spec:
  annotations:
    prometheus.kserve.io/port: "8082"
    prometheus.kserve.io/path: "/metrics"
  supportedModelFormats:
    - name: pytorch
      version: "1"
      autoSelect: true
      priority: 2
  protocolVersions:
    - v1
    - v2
    - grpc-v2
  containers:
    - name: kserve-container
      image: "pytorch/torchserve-kfs:0.9.0"
      args:
        - torchserve
        - --start
        - --model-store=/mnt/models/model-store
        - --ts-config=/mnt/models/config/config.properties
      env:
        - name: "TS_SERVICE_ENVELOPE"
          value: "{{.Labels.serviceEnvelope}}"
      securityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
            - ALL
        privileged: false
        runAsNonRoot: true
        runAsUser: 1000
      resources:
        requests:
          cpu: "1"
          memory: 2Gi
        limits:
          cpu: "1"
          memory: 2Gi
---
# Source: kserve/templates/clusterservingruntimes.yaml
apiVersion: serving.kserve.io/v1alpha1
kind: ClusterServingRuntime
metadata:
  name: kserve-tritonserver
spec:
  annotations:
    prometheus.kserve.io/port: "8002"
    prometheus.kserve.io/path: "/metrics"
  supportedModelFormats:
    - name: tensorrt
      version: "8"
      autoSelect: true
      priority: 1
    - name: tensorflow
      version: "1"
      autoSelect: true
      priority: 1
    - name: tensorflow
      version: "2"
      autoSelect: true
      priority: 1
    - name: onnx
      version: "1"
      autoSelect: true
      priority: 1
    - name: pytorch
      version: "1"
    - name: triton
      version: "2"
      autoSelect: true
      priority: 1
  protocolVersions:
    - v2
    - grpc-v2
  containers:
    - name: kserve-container
      image: "nvcr.io/nvidia/tritonserver:23.05-py3"
      args:
        - tritonserver
        - --model-store=/mnt/models
        - --grpc-port=9000
        - --http-port=8080
        - --allow-grpc=true
        - --allow-http=true
      securityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
            - ALL
        privileged: false
        runAsNonRoot: true
        runAsUser: 1000
      resources:
        requests:
          cpu: "1"
          memory: 2Gi
        limits:
          cpu: "1"
          memory: 2Gi
---
# Source: kserve/templates/clusterservingruntimes.yaml
apiVersion: serving.kserve.io/v1alpha1
kind: ClusterServingRuntime
metadata:
  name: kserve-xgbserver
spec:
  annotations:
    prometheus.kserve.io/port: "8080"
    prometheus.kserve.io/path: "/metrics"
  supportedModelFormats:
    - name: xgboost
      version: "1"
      autoSelect: true
      priority: 1
  protocolVersions:
    - v1
    - v2
  containers:
    - name: kserve-container
      image: "kserve/xgbserver:v0.14.0"
      args:
        - --model_name={{.Name}}
        - --model_dir=/mnt/models
        - --http_port=8080
        - --nthread=1
      securityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
            - ALL
        privileged: false
        runAsNonRoot: true
      resources:
        requests:
          cpu: "1"
          memory: 2Gi
        limits:
          cpu: "1"
          memory: 2Gi
---
# Source: kserve/templates/clusterservingruntimes.yaml
apiVersion: serving.kserve.io/v1alpha1
kind: ClusterServingRuntime
metadata:
  name: kserve-huggingfaceserver
spec:
  annotations:
    prometheus.kserve.io/port: "8080"
    prometheus.kserve.io/path: "/metrics"
  supportedModelFormats:
    - name: huggingface
      version: "1"
      autoSelect: true
      priority: 1
  protocolVersions:
    - v1
    - v2
  containers:
    - name: kserve-container
      image: "kserve/huggingfaceserver:v0.14.0"
      args:
        - --model_name={{.Name}}
      securityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
            - ALL
        privileged: false
        runAsNonRoot: true
      resources:
        requests:
          cpu: "1"
          memory: 2Gi
        limits:
          cpu: "1"
          memory: 2Gi
---
# Source: kserve/templates/modelmesh/clusterservingruntimes.yaml
apiVersion: serving.kserve.io/v1alpha1
kind: ClusterServingRuntime
metadata:
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
    name: modelmesh-serving-mlserver-1.x-SR
  name: mlserver-1.x
spec:
  builtInAdapter:
    serverType: mlserver
    runtimeManagementPort: 8001
    memBufferBytes: 134217728
    modelLoadingTimeoutMillis: 90000
  containers:
    - env:
        - name: MLSERVER_MODELS_DIR
          value: /models/_mlserver_models/
        - name: MLSERVER_GRPC_PORT
          value: "8001"
        - name: MLSERVER_HTTP_PORT
          value: "8002"
        - name: MLSERVER_LOAD_MODELS_AT_STARTUP
          value: "false"
        - name: MLSERVER_MODEL_NAME
          value: dummy-model-fixme
        - name: MLSERVER_HOST
          value: 127.0.0.1
        - name: MLSERVER_GRPC_MAX_MESSAGE_LENGTH
          value: "-1"
      image: seldonio/mlserver:1.3.2
      name: mlserver
      resources:
        requests:
          cpu: 500m
          memory: 1Gi
        limits:
          cpu: "5"
          memory: 1Gi
  grpcDataEndpoint: port:8001
  grpcEndpoint: port:8085
  multiModel: true
  protocolVersions:
    - grpc-v2
  supportedModelFormats:
    - name: sklearn
      version: "0"
      autoSelect: true
    - name: xgboost
      version: "1"
      autoSelect: true
    - name: lightgbm
      version: "3"
      autoSelect: true
---
# Source: kserve/templates/modelmesh/clusterservingruntimes.yaml
apiVersion: serving.kserve.io/v1alpha1
kind: ClusterServingRuntime
metadata:
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
    name: modelmesh-serving-ovms-1.x-SR
  name: ovms-1.x
spec:
  builtInAdapter:
    memBufferBytes: 134217728
    modelLoadingTimeoutMillis: 90000
    runtimeManagementPort: 8888
    serverType: ovms
  containers:
    - args:
        - --port=8001
        - --rest_port=8888
        - --config_path=/models/model_config_list.json
        - --file_system_poll_wait_seconds=0
        - --grpc_bind_address=127.0.0.1
        - --rest_bind_address=127.0.0.1
      image: openvino/model_server:2022.2
      name: ovms
      resources:
        limits:
          cpu: 5
          memory: 1Gi
        requests:
          cpu: 500m
          memory: 1Gi
  grpcDataEndpoint: port:8001
  grpcEndpoint: port:8085
  multiModel: true
  protocolVersions:
    - grpc-v1
  supportedModelFormats:
    - name: openvino_ir
      version: opset1
      autoSelect: true
    - name: onnx
      version: "1"
---
# Source: kserve/templates/modelmesh/clusterservingruntimes.yaml
apiVersion: serving.kserve.io/v1alpha1
kind: ClusterServingRuntime
metadata:
  annotations:
    maxLoadingConcurrency: "2"
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
    name: modelmesh-serving-triton-2.x-SR
  name: triton-2.x
spec:
  builtInAdapter:
    memBufferBytes: 134217728
    modelLoadingTimeoutMillis: 90000
    runtimeManagementPort: 8001
    serverType: triton
  containers:
    - command:
        - /bin/sh
      args:
        - -c
        - >
          mkdir -p /models/_triton_models;
          chmod 777 /models/_triton_models;
          exec tritonserver
          --model-repository=/models/_triton_models
          --model-control-mode=explicit
          --strict-model-config=false
          --strict-readiness=false
          --allow-http=true
          --allow-sagemaker=false
      image: nvcr.io/nvidia/tritonserver:23.04-py3
      livenessProbe:
        exec:
          command:
            - curl
            - --fail
            - --silent
            - --show-error
            - --max-time
            - "9"
            - http://localhost:8000/v2/health/live
        initialDelaySeconds: 5
        periodSeconds: 30
        timeoutSeconds: 10
      name: triton
      resources:
        limits:
          cpu: "5"
          memory: 1Gi
        requests:
          cpu: 500m
          memory: 1Gi
  grpcDataEndpoint: port:8001
  grpcEndpoint: port:8085
  multiModel: true
  protocolVersions:
    - grpc-v2
  supportedModelFormats:
    - name: keras
      version: "2"
      autoSelect: true
    - name: onnx
      version: "1"
      autoSelect: true
    - name: pytorch
      version: "1"
      autoSelect: true
    - name: tensorflow
      version: "1"
      autoSelect: true
    - name: tensorflow
      version: "2"
      autoSelect: true
    - name: tensorrt
      version: "7"
      autoSelect: true
---
# Source: kserve/templates/modelmesh/clusterservingruntimes.yaml
apiVersion: serving.kserve.io/v1alpha1
kind: ClusterServingRuntime
metadata:
  annotations:
    maxLoadingConcurrency: "2"
  labels:
    app.kubernetes.io/instance: modelmesh-controller
    app.kubernetes.io/managed-by: modelmesh-controller
    app.kubernetes.io/name: modelmesh-controller
    name: modelmesh-serving-torchserve-0.x-SR
  name: torchserve-0.x
spec:
  supportedModelFormats:
    - name: pytorch-mar
      version: "0"
      autoSelect: true
  multiModel: true
  grpcEndpoint: "port:8085"
  grpcDataEndpoint: "port:7070"
  containers:
    - name: torchserve
      image: pytorch/torchserve:0.7.1-cpu
      args:
        # Adapter creates the config file; wait for it to exist before starting
        - while [ ! -e "$TS_CONFIG_FILE" ]; do echo "waiting for config file..."; sleep 1; done;
        - exec
        - torchserve
        - --start
        - --foreground
      env:
        - name: TS_CONFIG_FILE
          value: /models/_torchserve_models/mmconfig.properties
      resources:
        requests:
          cpu: 500m
          memory: 1Gi
        limits:
          cpu: "5"
          memory: 1Gi
  builtInAdapter:
    serverType: torchserve
    runtimeManagementPort: 7071
    memBufferBytes: 134217728
    modelLoadingTimeoutMillis: 90000
---
# Source: kserve/templates/clusterstoragecontainer.yaml
apiVersion: "serving.kserve.io/v1alpha1"
kind: ClusterStorageContainer
metadata:
  name: default
spec:
  container:
    name: storage-initializer
    image: "kserve/storage-initializer:v0.14.0"
    resources:
      requests:
        memory: 100Mi
        cpu: 100m
      limits:
        memory: 1Gi
        cpu: "1"
    securityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
          - ALL
      privileged: false
      runAsNonRoot: true
  supportedUriFormats:
    - prefix: gs://
    - prefix: s3://
    - prefix: hdfs://
    - prefix: webhdfs://
    - regex: "https://(.+?).blob.core.windows.net/(.+)"
    - regex: "https://(.+?).file.core.windows.net/(.+)"
    - regex: "https?://(.+)/(.+)"
  workloadType: initContainer
---
# Source: kserve/templates/certificate.yaml
apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: selfsigned-issuer
  namespace: kserve
spec:
  selfSigned: {}
---
# Source: kserve/templates/webhookconfiguration.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: MutatingWebhookConfiguration
metadata:
  name: inferenceservice.serving.kserve.io
  annotations:
    cert-manager.io/inject-ca-from: kserve/serving-cert
webhooks:
  - clientConfig:
      service:
        name: kserve-webhook-server-service
        namespace: kserve
        path: /mutate-serving-kserve-io-v1beta1-inferenceservice
    failurePolicy: Fail
    name: inferenceservice.kserve-webhook-server.defaulter
    sideEffects: None
    admissionReviewVersions: ["v1beta1"]
    rules:
      - apiGroups:
          - serving.kserve.io
        apiVersions:
          - v1beta1
        operations:
          - CREATE
          - UPDATE
        resources:
          - inferenceservices
  - clientConfig:
      service:
        name: kserve-webhook-server-service
        namespace: kserve
        path: /mutate-pods
    failurePolicy: Fail
    name: inferenceservice.kserve-webhook-server.pod-mutator
    sideEffects: None
    reinvocationPolicy: IfNeeded
    admissionReviewVersions: ["v1beta1"]
    objectSelector:
      matchExpressions:
        - key: serving.kserve.io/inferenceservice
          operator: Exists
    rules:
      - apiGroups:
          - ""
        apiVersions:
          - v1
        operations:
          - CREATE
        resources:
          - pods
---
# Source: kserve/templates/modelmesh/webhookconfiguration.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: modelmesh-servingruntime.serving.kserve.io
  annotations:
    cert-manager.io/inject-ca-from: kserve/modelmesh-webhook-server-cert
webhooks:
  - admissionReviewVersions:
      - v1
    clientConfig:
      caBundle: Cg==
      service:
        name: modelmesh-webhook-server-service
        namespace: kserve
        path: /validate-serving-modelmesh-io-v1alpha1-servingruntime
        port: 9443
    failurePolicy: Fail
    name: servingruntime.modelmesh-webhook-server.default
    rules:
      - apiGroups:
          - serving.kserve.io
        apiVersions:
          - v1alpha1
        operations:
          - CREATE
          - UPDATE
        resources:
          - clusterservingruntimes
    sideEffects: None
---
# Source: kserve/templates/webhookconfiguration.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: inferenceservice.serving.kserve.io
  annotations:
    cert-manager.io/inject-ca-from: kserve/serving-cert
webhooks:
  - clientConfig:
      service:
        name: kserve-webhook-server-service
        namespace: kserve
        path: /validate-serving-kserve-io-v1beta1-inferenceservice
    failurePolicy: Fail
    name: inferenceservice.kserve-webhook-server.validator
    sideEffects: None
    admissionReviewVersions: ["v1beta1"]
    rules:
      - apiGroups:
          - serving.kserve.io
        apiVersions:
          - v1beta1
        operations:
          - CREATE
          - UPDATE
        resources:
          - inferenceservices
---
# Source: kserve/templates/webhookconfiguration.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: trainedmodel.serving.kserve.io
  annotations:
    cert-manager.io/inject-ca-from: kserve/serving-cert
webhooks:
  - clientConfig:
      service:
        name: kserve-webhook-server-service
        namespace: kserve
        path: /validate-serving-kserve-io-v1alpha1-trainedmodel
    failurePolicy: Fail
    name: trainedmodel.kserve-webhook-server.validator
    sideEffects: None
    admissionReviewVersions: ["v1beta1"]
    rules:
      - apiGroups:
          - serving.kserve.io
        apiVersions:
          - v1alpha1
        operations:
          - CREATE
          - UPDATE
        resources:
          - trainedmodels
---
# Source: kserve/templates/webhookconfiguration.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  creationTimestamp: null
  name: inferencegraph.serving.kserve.io
  annotations:
    cert-manager.io/inject-ca-from: kserve/serving-cert
webhooks:
  - clientConfig:
      service:
        name: kserve-webhook-server-service
        namespace: kserve
        path: /validate-serving-kserve-io-v1alpha1-inferencegraph
    failurePolicy: Fail
    name: inferencegraph.kserve-webhook-server.validator
    sideEffects: None
    admissionReviewVersions: ["v1beta1"]
    rules:
      - apiGroups:
          - serving.kserve.io
        apiVersions:
          - v1alpha1
        operations:
          - CREATE
          - UPDATE
        resources:
          - inferencegraphs
---
# Source: kserve/templates/webhookconfiguration.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  creationTimestamp: null
  name: clusterservingruntime.serving.kserve.io
  annotations:
    cert-manager.io/inject-ca-from: kserve/serving-cert
webhooks:
  - clientConfig:
      service:
        name: kserve-webhook-server-service
        namespace: kserve
        path: /validate-serving-kserve-io-v1alpha1-clusterservingruntime
    failurePolicy: Fail
    name: clusterservingruntime.kserve-webhook-server.validator
    sideEffects: None
    admissionReviewVersions: ["v1beta1"]
    rules:
      - apiGroups:
          - serving.kserve.io
        apiVersions:
          - v1alpha1
        operations:
          - CREATE
          - UPDATE
        resources:
          - clusterservingruntimes
---
# Source: kserve/templates/webhookconfiguration.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  creationTimestamp: null
  name: servingruntime.serving.kserve.io
  annotations:
    cert-manager.io/inject-ca-from: kserve/serving-cert
webhooks:
  - clientConfig:
      service:
        name: kserve-webhook-server-service
        namespace: kserve
        path: /validate-serving-kserve-io-v1alpha1-servingruntime
    failurePolicy: Fail
    name: servingruntime.kserve-webhook-server.validator
    sideEffects: None
    admissionReviewVersions: ["v1beta1"]
    rules:
      - apiGroups:
          - serving.kserve.io
        apiVersions:
          - v1alpha1
        operations:
          - CREATE
          - UPDATE
        resources:
          - servingruntimes
